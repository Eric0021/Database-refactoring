
All seven issues are solved.
The first issue is solved using the flyweight pattern. The classes used are in the FlyWeight package. The data of each individual, unique report is stored in the Data class, which is a value object. A collection of these data is then stored in ReportFactory. The report class uses ReportFactory to retrieve its own data. This means that even though reports are cloned in the ReportDatabase, the duplicates use the same data, therefore reducing RAM. This solution runs on the assumption that data for each unique report is not edited in the database after they are loaded into ReportFactory.
The second issue is solved using a combination of the bridge, visitor, factory and facade pattern. The relevant files are located in the Bridge, Factory and Visitor packages. Inheritance is mostly replaced with composition, where each order type holds a Critical and ScheduledOrder object. The Visitor objects modify the behaviour of methods which change according to the type, critical and scheduled properties of an Order. Factories are used to create each type of Order. The OrderFactoryHandler and Visitors class encapsulate the use of their respective pattern. The ScheduledFacade class decouples the OrderBase class from the ScheduledOrder class.
The third issue is solved with a chain of responsibility pattern. The relevant classes are located in the Chain package. The ContactHandler class starts the chain and each Chain of Responsibility class will either execute its own sendInvoice() method or delegate to the next class in the chain. This eliminates the bulky switch case statements. 
The fourth issue is solved with the lazy load pattern. The ClientImpl class is modified so that its variables are only retrieved from the database when they are needed, in other words when their getter method is called. 
The fifth issue is solved by making the ReportImpl class a value object. This means that its equality with another ReportImpl is based on the value of its variables, not the classï¿½ identity. A new equals() and hashCode() method is defined for this class. When reports need to be compared for equality, the equals() method can be called, simplifying the process.
The sixth issue is solved by using the unit of work pattern. The relevant classes are in the UnitOfWork package. The FEAAFacade class holds an instance of the OrderUnitOfWork class, any new orders or edited orders are cached in the OrderUnitOfWork class. The changes will only be committed when the user logs out, or the number of finalised orders reaches 10.
The seventh issue is solved by using threads in the FEAAFacade and OrderUowImpl classes. In OrderUoWImpl, the remove(), commit() and registerDirty() methods are all delegated to a new thread. Also, only one of the three methods can run at one time as they are each synchronised. This allows the system to be used while these methods, especially commit(), are running in the background. In FEAAFacade, getAllOrders() and getAllReports() both use threads to improve performance. Lastly, in FEAAFacade's logout() method, the main thread will wait for all other threads to finish before logging out.
The code is formatted in google java style.
